#### 1. Java 反射与注解

##### 	1.1 反射

​		本质：在程序运行期间动态，隐式（事先不知创建何对象）的创建对象。可突破private

```java
步骤：
	//1.获取类信息
	Class cls = Class.forName("类的路径");
	//2.得到声明的构造方法
	constructor = cls.getDeclaredConstructor(parameterTypes:如String.clss);
	//3.进行实例化
	object o = constructor.newInstance(参数1，参数2，...);
        //4.获取实例化对象的内部声明的属性
        Field f = o.getClass().getDeclaredField(属性参数);
        //5.将属性设置为可访问的(若是private)
        f.setAccessible(true);
        //6.访问
		field.get(obj);
        //7.获取实例化对象声明的方法
        method = o.getClass().getDeclaredMethod(方法名称，参数类型的类);
        //8.将方法设置为可访问的(若是private);
        method.setAccessible(true);
        //9.调用方法
        method.invoke(调用该方法对象，参数数组);
```

##### 1.2 注解

​	本质：注解实质是一个标记，通过反射实现特定的功能。

```java
1.应用注解
public class Dog {
    @MyAnnotation("小黄")
    private String name;
    @MyAnnotation("黄色")
    private String color;
    public Dog(){
    }
}
2.自定义注解
@Documented
@Target(ElementType.FIELD)//元注解 指定范围
@Retention(RetentionPolicy.RUNTIME)//元注解，指定什么时期有效
public @interface MyAnnotation {
    String value();//String：参数类型 value():方法接受参数
}
3.应用反射执行注解特定功能，主要是看其是否添加了某些注解
//对属性遍历是否添加了注解
for (Field declaredField : declaredFields) {
     MyAnnotation annotation = declaredField.getAnnotation(MyAnnotation.class);
         if(annotation!=null){
             //得到注解的参数
             String value = annotation.value();
             //暴力反射，突破private
             declaredField.setAccessible(true);
             //完成赋值注解
             declaredField.set(dog,value);
            }
}
//得到对象属性数组
Field[] declaredFields1 = dog.getClass().getDeclaredFields();
//遍历属性数组
for (Field field : declaredFields1) {
	//暴力反射
 	field.setAccessible(true);
    //属性调用get得到对象的值
    System.out.println(field.get(dog));
}
//类似性
field.get(obj) == obj.get(field);
declaredField.set(obj,value) == obj.set(declardField,value)
```

